* Git Foundations

** [#C] Git Foundations Class Description
*** Distributed version control is all the rage these days, but is it worth it? It has been transformative for the dozens of organizations and thousands of developers that I've mentored on the unique implementation called Git. But don't take my word for it. Discover the joy of a version control system that works for you, not against you, in a hands-on workshop. Bring a Windows, Mac, or Linux laptop and we'll install, set up, use and bend Git into workflows that weren't even possible with the version control systems of yesteryear. Be prepared to rethink how lightweight, fast, and refreshing source code control can be. After completing this workshop you'll be able to do practical work with Git for your day job or weekend OSS hobby.

** [#A] Repo URLs, Links, Setup
*** Workshop Materials
**** https://github.com/matthewmccullough/git-workshop
*** Sample Project
**** https://github.com/matthewmccullough/hellogitworld
*** Shell Scripts
**** https://github.com/matthewmccullough/scripts
*** Shell Decorations
**** https://github.com/matthewmccullough/MatthewsShellConfig
*** Cheat Sheet
**** http://refcardz.dzone.com/refcardz/getting-started-git
*** GitHubStudents Temp Account
**** `git clone https://githubstudents:students987@github.com/githubstudents/hellogitworld.git`
*** Created a Gist for Notes
**** https://gist.github.com/1589518
*** Office Hours and GitHub Welcome Class
**** https://github.com/blog/970-more-github-office-hours-and-welcome-classes :short:medium:long:

** [#B] What is Git?
   :PROPERTIES:
   :Effort:   5
   :END:
*** Linux origins
*** Why a distributed version control system?
*** How does Git differ from previous VCS systems?

** [#A] Installing Git
   :PROPERTIES:
   :Effort:   10
   :END:
*** The 5 minute litmus test
*** No systemic intrusions
*** Ask for a USB Stick if you need binaries
*** Test Git
**** Open your terminal
***** Mac: Terminal or iTerm
***** Linux: Terminal
***** Windows: Git Bash Prompt
**** `git --version`
        Output:
        git version 1.7.8.2

** [#A] Creating Local Repositories
We can create repos even before we configure Git
*** `git init`
**** On exisiting code or folders
**** Legacy repo creation syntax
*** `git init <REPONAME>`
**** For a brand new project
**** Recent convenience syntax (1.7 era)

** [#A] Configuring Git Identity
*** Git Config
**** Local
**** Global
**** System
*** Your Name & Email
**** git config --global user.name "Matthew McCullough"
**** git config --global user.email "matthew@github.com"
** [#B] Configuring Editor and Color Behavior
*** Your Editor
**** git config --global core.editor "mate -w"
**** GitPad for Windows
*** Color
**** git config --global color.ui "auto"

** [#B] Configuring Git Line Ending Behavior
*** Line Ending Conversion
**** autocrlf
*** Line Ending Warnings
**** safecrlf
** [#A] Adding and Commiting Basics
*** Add
Add can use specific filenames or wildcards. Add uses glob pattern matching.
**** `git add <FILENAME>`
The most specific
**** `git add <PATTERN>`
A subset of the files
**** `git add *.html`
Just the HTML files
**** `git add src/`
The src directory
**** `git add .`
Everything in this directory and recursively beneath it
**** Interactive selection of code
More than just file level precision is available in Git. Hunks within files can be chosen in the interactive modes of some commands.
***** `git add -p`
*** Commit
Makes staged code a permanent part of history
**** `git commit -m"message here"`
Writes a commit to the .git/objects directory

** [#A] History Viewing Basics
*** ==git log==
Lists all history in reverse chronological order
*** ==git log -3==
Just the last three entries
*** ==git log --stat==
Show filenames
*** ==git log -p==
Show contents (patch format) of historical changes

** [#B] Advanced History
*** ==git log --diff-filter=M==
Only files that are modified. Can also use D, R, A for other modes of files
*** ==git log --author=Matthew==
Substring match
*** ==git log --pretty=oneline --graph --decorate --abbrev-commit --all==
Show all history in a graph, decorated with branch names, shorten the commit refs to 7 characters, and show all branches, not just ones that are merged into this one.
** [#B] Three Stage Thinking
*** Why Git has three trees
**** Working Directory (File System)
**** Staging Area (Index)
**** Repository (Commit History)
*** Why Git has a staging area
**** Shopping cart
**** Select, then act
**** Durable between work sessions
*** Why Git cares about content
**** Content tracker, not just a file tracker
**** Understands line (word) changes
**** Similarity index
**** Tracks code movement across renames, moves, and refactoring

** [#B] Git Hashing Basics
*** What is a hash?
**** Fingerprint
**** Unique content identification
**** SHA1
**** 160 bits
**** 40 hex characters
*** Why hashing?
**** Unique content has a unique identifier
**** GUID
**** 2^160 possible identifiers
*** What is Hashed?
**** Blob
**** Tree
**** Commit
**** Tag

** [#B] Hash Navigation Language
*** Commitish
**** The most common meaning
**** What we generally mean when we say a "ref" or a "sha"
*** Treeish
**** Points to a tree
**** Less frequently used

** [#B] DAGs & The Commit Graph
*** Graph, with limitations
*** Always traveling forward
*** No loops
*** New elements point to ancestors
*** Liked linked lists

** [#B] Treeish, Commitish
*** Graph navigation language
*** Uses `^` and `~` and `@{}` and `...` symbols
*** Use of subset of hash characters
**** 40 hex characters
**** 20 bytes
**** 160 bits
**** Can use as little as 4 characters
**** Standard is 7
*** Two commits ago:
**** `HEAD@{2}`
*** Two commits ago:
**** `HEAD^^`
*** Two commits ago
**** `HEAD~2`
*** Range from the local commits to the remote commits
**** `master..origin/master`

** [#B] More Precise Commit Contents
*** Write code, change files
**** Separates changing files from commiting files
**** Can change more than you intend to commit
**** Can group what you changed for your commits
*** Add only what's ready for consumption
**** Don't commit "less than ready" code
**** Stash away what you want to restore to pristine state
*** Commit only a portion of file changes
**** Patch mode
***** git add -p
***** git stash -p
***** git reset -p
**** Stash
***** Put "away" entire files not ready for commit
***** Multiple stashes, but don't confuse them for real branches

** [#A] Cloning
*** Hello Git World repo via three addresses
**** https://matthewmccullough@github.com/matthewmccullough/hellogitworld.git
**** git://github.com/matthewmccullough/hellogitworld.git
**** git@github.com:matthewmccullough/hellogitworld.git
*** Each protocol type has minor differences
**** file://
**** git://
**** git+ssh://
**** http://
**** https://
**** Resulting repo is the same, no matter the protocol

** [#A] Branching Concepts
*** Branches are cheap: 40 hex chars
**** Files in `.git/refs`
*** Used to contain experiments, stories, and features.
*** Branches begin life locally and are only published as requested
**** This makes branches suitable for experiments

** [#A] Basic Branching Mechanics
*** Creating branches for later
**** ==git branch <BRANCHNAME>==
*** Creating branches for immediate use
**** git checkout -b <BRANCHNAME>
*** Deleting
**** ==git branch -D <BRANCHNAME>==
**** ==git branch -d <BRANCHNAME>==

** [#B] Reset
*** Affects the index, possibly the current branch HEAD, and potentially working directory
*** git reset --hard
**** Discard working directory and index
**** Defaults to HEAD
**** `git reset --hard HEAD`
**** `git reset --hard`
*** git reset --soft
**** Destroy history, but leave working directory and stash the same
**** Permits a re-commit
**** `git reset --soft HEAD~1`
*** git reset --mixed
**** `git reset --mixed`
** [#A] Remote Basics
*** Just bookmarks for URLs
*** One by default called `origin`
*** Add as many as you like
**** Very different from centralized version control
**** `git remote add <REMOTENAME> <URL>`
**** Multiple named destinations for code

** [#B] Remote Details
*** What gets retrieved from a remote?
**** Default refspec
**** Can address with greater precision with custom editing in .git/config
*** Editing remotes
**** Adding
**** Removing
**** Renaming
*** Why are remote branches immutable?
**** Local cache
**** Like browser cache

** [#B] Navigating the Tree
*** diff
*** ls-tree
*** show

** [#B] Git Internals
*** Plain Text Config
**** .gitconfig
**** .git/config
**** .git/HEAD
**** .git/FETCH_HEAD
**** .git/COMMIT_EDITMSG
*** Git exposes its internals
**** Composed construction
**** Porcelain and plumbing
*** Can discover the data structures
**** Git manipulates graphs
**** Many git commands just change file pointers in .git

** [#A] Network Operations
*** Cloning
*** Remotes
*** Pushing
*** Pulling
*** Fetching

** [#A] Merging Basics
*** Merge tags, branches and arbitrary hashes
**** `git merge <TAG>`
**** `git merge <BRANCH>`
**** `git merge <9fa321e>`
*** Outcomes
**** "merge made by recursive"
**** "fast-forward"
*** Query Branch Merge Status
**** ==git branch --merged==
Which branches are merged?
**** ==git branch --no-merged==
Which branches are not merged into this one?
     
** [#B] Merging Techniques
*** Octopus
**** Multiple branches at once
**** More efficient than sequentially
*** Strategies
**** `git merge -s ours <BRANCH>`
**** `-s subtree`
**** `-s ours`
**** There is no `theirs`
*** No Commit (Pause)
**** `--no-commit`
**** Only works with recursive
**** Fast-forward will still commit (no merge commit)
*** No Fast-Forward (Merge Commit Forced)
**** `--no-ff`
**** Force a merge commit, even if not needed
**** Provides permanent record of merge (and possibly the feature being merged in)
*** Choosing a side per file
**** git checkout --ours <filename>
**** git checkout --theirs <filename>

** [#A] Rebasing On A Branch
*** History Rewriting for Clarity
**** Code change clarity
**** Multi-commit unification
**** History linearity
**** Commit message cleanup
*** Traditional rebase
**** Common to put the contents of one branch after the master branch
**** ==git rebase <COMMIT>==
Rebases the current branch as if it branched from the <COMMIT> specified

** [#B] Interactive Rebase
User-involved rebasing to change order, message, contents
*** Functions
**** Reword
**** Squash
**** Omit
**** Edit
*** Executing an Interactive Rebase
**** ==git rebase -i <COMMIT>==
**** ==git rebase --continue==
**** ==git rebase --skip==
**** Never commit while in a rebase (will orphan the commit)

** [#C] Automatic Rebase 
*** Fixup
*** Autosquash

** [#B] Rebase Impacts
*** Hashses have changed
*** Might have to force push
**** Repercussions to team
**** Is this ever viable?
**** Git project rebases PU branch all the time
*** Leaving the merge bubble after rebase
**** Keeps visual representation of feature work
**** `merge --no-ff`

** [#B] Diff and Merge Tools (Visual)
*** Difftool
**** `git difftool <REF1> <REF2>`
**** For staged and unstaged changes
**** Diffing arbitrary branches
**** Doesn't require any specific "state"
*** Mergetool
**** `git mergetool`
**** For merge conflicts
**** Requires merge conflict to activate
*** Configuration in .gitconfig
*** Selection at CLI
**** `git difftool -t araxis`
**** `git mergetool -t araxis`
**** `git difftool -t opendiff`
*** Default supported tools
**** `git help difftool`
**** P4Merge
**** OpenDiff
**** VimDiff
**** Araxis
**** BeyondCompare
**** Anything that accepts command line parameters

** [#A] History Modification
Git permits history to be modified in a variety of ways. This is a sharp tool, but extremely useful in the hands of proficient developers.
*** Reset
Change the staging area and the commit graph.
**** ==git reset --hard==
**** ==git reset --hard HEAD==
Reset all tracked and staged files to the last committed state
**** ==git reset --soft HEAD~1
Redo the last commit. Put all committed files back in
*** Amend
**** ==git commit --amend==
Redo the last commit. Can have files modified, then staged or added then staged, or removed then staged that will be part of this re-done commit.
**** Caution should be employed for any pushed commits because the commit hash has been re-calculated 
*** Rebase
Replay existing commits. Possibly interactively.
*** Reflog
**** ==git reflog==
Show the local journal of changes to your repo
**** ==git reset --hard <REF>==
Restore to a commit from your reflog

** [#B] Workflows
*** Offline sharing
*** Pushing and pulling
*** Commander, lieutenant and soldier
*** Centralized

** [#C] Dev Tool & IDE Git Integration
*** Eclipse
*** IntelliJ
*** TextMate
*** Emacs
*** Vim
*** Visual Studio

** [#C] Web Tools
*** git instaweb
*** viewvc
*** bananajour

** [#C] Repo Hosting
*** Web tools
*** Gitolite
*** Gitorious
*** GitHub:Enterprise

*** Git hosting

** [#B] Refspecs
*** Control what is pulled
*** Control what is pushed
*** Notes
*** Tags

** [#B] Precision Actions
*** Merging a single file
**** git checkout 
*** Displaying a file at a certain point in time
**** git show TREEISH:filename

** [#B] Broad Actions
*** Logging ranges
**** git log SINCE..TO
*** Diffing arbitrary hashes
**** git diff ANYFROM ANYTO

** [#B] Branching Strategies
*** What code belongs where?
*** Good branching
**** Small
**** Quickly merged
**** Well named
*** Branch lifetimes
**** Long lived branches
**** Integration branches
**** Short lived (topic) branches
*** Naming conventions
**** Slashes in the name?
**** Usernames in the branch name (like the git project)
**** ls-remote becomes more helpful
*** Merge and rebase techniques from the field

** [#B] GitHub
*** Hosted Git repos

** [#C] Hashing Examples In The Real World
*** Names (3 letters + 1) on United screens
*** First letter plus last on bulletins
*** Trying to make a unique thing out of a non unique or large thing (full name)
*** Trying to obscure the data but still offer a unique fingerprint

** [#B] Eclipse
*** JGit
*** EGit
*** New 1.2 feautures such as patch mode staging
*** Gists

** [#B] End of Foundations Class Q&A
*** Tooling suggestions?
*** Branch strategies?
*** Git repo hosting?
*** Git backup strategies?
*** Getting code off developer laptops
*** How to handle hooks
*** Using GitHub


* Git Advanced
** [#A] Git Advanced Class Description
Many Git workshops successfully focus on the basics for those new to DVCS. However, with Git having a full 5 years on the street now, there is a growing desire to address the maturing users of this innovative DVCS. This workshop will take existing Git users and bring them to a heightened level of productivity by leveraging Git’s powerful, yet underused “advanced” features.

** [#B] Branching Strategies, Team Collaboration Techniques
*** Branch By Feature
**** Made popular on Git by Vincent Driessen and his NVIE site
**** http://nvie.com/posts/a-successful-git-branching-model/
**** https://github.com/nvie/gitflow
*** Open Source Branch By Feature
**** SpringSource,
**** http://blog.springsource.com/2010/12/21/git-and-social-coding-how-to-merge-without-fear/
*** GitHub Branch By Feature
**** https://github.com/blog/919-how-github-develops
**** http://scottchacon.com/2011/08/31/github-flow.html
*** Git's model
**** http://members.cox.net/junkio/git/MaintNotes.html
**** https://github.com/git/git
**** Branches
***** master
***** maint
***** next (graduation from pu)
***** pu (can be rebased)
***** html
***** man
**** Creating a parentless branch
***** git checkout --orphan 

** [#B] Applying road-tested branching strategies.
*** Pull requests on branches, not just commits
**** Leaves the PR open to enhancements, feedback, continued contributions
*** Collapse branches quickly
**** Fine to delete branches once merged
**** Some teams prefer --no-ff on their merges
*** Never commit to trunk
**** Possibly only accept pull requests
*** Rebase branches
**** git config --local branch.autosetuprebase "always"
**** git pull --rebase
*** Portable commits
**** Bundles
*** git bundle create master mymaster.bundle


** [#A] Cherry picking bug fixes and other nuggets of code
*** Works in both linear and rebase workflows
*** Cherry pick from customer branch
**** Can be picked from anywhere
*** Interactively rebase and edit on the desired commit
**** Amend that commit
==git commit --amend==
**** Rebase continue
==git rebase --continue==

** [#B] Building custom commands via aliases and shell scripts.
*** gc_recursive
*** finddirtygit
*** servehere
**** git daemon --export-all --base-path=. --enable=receive-pack
**** git fetch git://

** [#A] Undoing and redoing almost anything via revert, reset, reflog and stash.
*** Revert
*** Reset
**** Soft
**** Hard

** [#A] Minimizing repetitive work with rerere
*** Uses
**** Reuse Recorded Resolution
**** Memorizes conflict resolution.
**** Local only. Not portable. Saves to rerere log file.
*** Turn on rerere
**** git config --global rerere.enabled "1"
*** Test rerere
**** Merge twice on the same information
*** Inquiry on rerere status
**** git rerere status
**** git rerere diff
** [#A] Advanced History Searches
*** git log -S "STRING"
*** git log -G "regex"
*** git log --grep "<PATTERN>"
*** git log --follow FILENAME
*** git log --follow REF:FILENAME
*** git log -p -S "option = options[0];" --diff-filter=D
*** Listing specifics
**** Untracked files:
**** git ls-files . --exclude-standard --others
**** Ignored files:
**** git ls-files . --ignored --exclude-standard --others

** [#B] Leveraging fixup, autosquash, squash and interactive rebase
*** Fluidly make source history more comprehensible.
*** Interactive Rebase
**** ==git rebase -i <REF>==
*** Squash
**** git merge --squash
**** git rebase -i 
*** Fixup
**** ==git commit -m"FIXUP! Message Here"==
*** Aliases
**** AutoSquash Script
***** By Jacob Helwig
***** http://technosorcery.net/2010/02/07/fun_with_the_upcoming_1.7_release_of_git_rebase_--interactive_--autosquash.html
***** fixup = !sh -c 'git commit -m \"fixup! $(git log -1 --format='\\''%s'\\'' $@)\"' -
***** squash = !sh -c 'git commit -m \"squash! $(git log -1 --format='\\''%s'\\'' $@)\"' -
***** ri = rebase --interactive --autosquash

* To Be Integrated
** git cherry
** git rebase --onto

